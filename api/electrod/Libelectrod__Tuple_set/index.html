<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Libelectrod__Tuple_set (electrod.Libelectrod__Tuple_set)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">electrod</a> &#x00BB; Libelectrod__Tuple_set</nav><h1>Module <code>Libelectrod__Tuple_set</code></h1></header><aside><p>Type for sets of tuples.</p></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>Set of tuples. Invariant: all tuples in the tuple set have the same arity</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="index.html#type-t">t</a></code></dt><dd><p>The empty tuple set.</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val</span> singleton : <a href="../Libelectrod/Tuple/index.html#type-t">Libelectrod.Tuple.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="../Libelectrod/Tuple/index.html#type-t">Libelectrod.Tuple.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-of_tuples"><a href="#val-of_tuples" class="anchor"></a><code><span class="keyword">val</span> of_tuples : <span><a href="../Libelectrod/Tuple/index.html#type-t">Libelectrod.Tuple.t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Requires: <code>tuples</code> is a nonempty list for tuples of the same arity.</p></dd></dl><dl><dt class="spec value" id="val-inferred_arity"><a href="#val-inferred_arity" class="anchor"></a><code><span class="keyword">val</span> inferred_arity : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Arity of a tuple set. 0 if the set is empty, <code>n &gt; 0</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Tells whether the tuple set denotes the empty set.</p></dd></dl><dl><dt class="spec value" id="val-tuples"><a href="#val-tuples" class="anchor"></a><code><span class="keyword">val</span> tuples : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Libelectrod__Tuple/index.html#module-Set">Libelectrod.Tuple.Set</a>.t</code></dt><dd><p>Tuples in a tuple set.</p></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Computes the union of two tuple sets <code>b1</code> and <code>b2</code>.</p><p>Requires: <code>b1</code> and <code>b2</code> have the same arity.</p></dd></dl><dl><dt class="spec value" id="val-inter"><a href="#val-inter" class="anchor"></a><code><span class="keyword">val</span> inter : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Computes the intersecion of two tuple sets <code>b1</code> and <code>b2</code>.</p></dd></dl><dl><dt class="spec value" id="val-product"><a href="#val-product" class="anchor"></a><code><span class="keyword">val</span> product : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>product b1 b2</code> computes the <b>flat</b> product of <code>b1</code> and <code>b2</code>. Recall the product is empty if any of <code>b1</code> or <code>b2</code> is.</p></dd></dl><dl><dt class="spec value" id="val-subset"><a href="#val-subset" class="anchor"></a><code><span class="keyword">val</span> subset : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>subset b1 b2</code> returns <code>true</code> if <code>b1</code> is included in <code>b2</code>.</p></dd></dl><dl><dt class="spec value" id="val-override"><a href="#val-override" class="anchor"></a><code><span class="keyword">val</span> override : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Computes the override <code>b1 ++ b2</code> of two tuple sets <code>b1</code> and <code>b2</code>.</p></dd></dl><dl><dt class="spec value" id="val-lproj"><a href="#val-lproj" class="anchor"></a><code><span class="keyword">val</span> lproj : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Computes the left projection <code>s &lt;: r</code> of a set <code>s</code> and a relation <code>r</code>.</p></dd></dl><dl><dt class="spec value" id="val-rproj"><a href="#val-rproj" class="anchor"></a><code><span class="keyword">val</span> rproj : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Computes the right projection <code>r :&gt; s</code> of a relation <code>r</code> and a set <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal b1 b2</code> returns <code>true</code> if <code>b1</code> is equal <code>b2</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Compares tuple sets against the inclusion ordering</p></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <a href="../Libelectrod/Tuple/index.html#type-t">Libelectrod.Tuple.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem t ts</code> tells whether <code>t</code> is in <code>ts</code>.</p></dd></dl><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val</span> size : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Cardinality of a tuple set</p></dd></dl><dl><dt class="spec value" id="val-diff"><a href="#val-diff" class="anchor"></a><code><span class="keyword">val</span> diff : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Set difference.</p></dd></dl><dl><dt class="spec value" id="val-transpose"><a href="#val-transpose" class="anchor"></a><code><span class="keyword">val</span> transpose : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Transposition.</p></dd></dl><dl><dt class="spec value" id="val-diagonal"><a href="#val-diagonal" class="anchor"></a><code><span class="keyword">val</span> diagonal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Diagonal of a set.</p></dd></dl><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Join of two tuple sets.</p></dd></dl><dl><dt class="spec value" id="val-transitive_closure"><a href="#val-transitive_closure" class="anchor"></a><code><span class="keyword">val</span> transitive_closure : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Guess.</p></dd></dl><dl><dt class="spec value" id="val-transitive_closure_is"><a href="#val-transitive_closure_is" class="anchor"></a><code><span class="keyword">val</span> transitive_closure_is : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Computes the transitive closure of a tuple set using iterative sqaures</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : <span>(<a href="../Libelectrod/Tuple/index.html#type-t">Libelectrod.Tuple.t</a> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Filters tuples depending on a predicate.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<a href="../Libelectrod/Tuple/index.html#type-t">Libelectrod.Tuple.t</a> <span>&#45;&gt;</span> <a href="../Libelectrod/Tuple/index.html#type-t">Libelectrod.Tuple.t</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-rename"><a href="#val-rename" class="anchor"></a><code><span class="keyword">val</span> rename : <span><span>(<a href="../Libelectrod/Atom/index.html#type-t">Libelectrod.Atom.t</a>, <a href="../Libelectrod/Atom/index.html#type-t">Libelectrod.Atom.t</a>)</span> Containers.List.Assoc.t</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_iter"><a href="#val-to_iter" class="anchor"></a><code><span class="keyword">val</span> to_iter : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../Libelectrod/Tuple/index.html#type-t">Libelectrod.Tuple.t</a> CCSet.sequence</span></code></dt><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../Libelectrod/Tuple/index.html#type-t">Libelectrod.Tuple.t</a> list</span></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Libelectrod/Intf/Print/index.html#module-type-S">Libelectrod.Intf.Print.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Libelectrod/Intf/Print/module-type-S/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span><a href="index.html#type-t">t</a> <a href="../Libelectrod/index.html#module-Fmtc">Libelectrod.Fmtc</a>.t</span></code></dt><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt></dl></details></div></div></div></div></body></html>